import requests
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple, Union
import math
import time
from collections import deque
import os

class BlackHoleEscape:
    def __init__(self, client_id: str, client_secret: str, save_responses: bool = True):
        """
        Initialize the BlackHoleEscape system with 42 API credentials
        
        Args:
            client_id: 42 API client ID
            client_secret: 42 API client secret
            save_responses: If True, saves all API responses to JSON files
        """
        self.base_url = "https://api.intra.42.fr"
        self.client_id = client_id
        self.client_secret = client_secret
        self.access_token = None
        self.rate_limit_queue = deque()
        self.save_responses = save_responses
        
        # Create directory for API responses
        if self.save_responses:
            self.api_responses_dir = "api_responses"
            os.makedirs(self.api_responses_dir, exist_ok=True)
            print(f"üìÅ API responses will be saved to: {self.api_responses_dir}/")
        
        self.authenticate()
    
    def rate_limit_delay(self):
        """Implement rate limiting: 2 requests per second"""
        now = time.time()
        while self.rate_limit_queue and now - self.rate_limit_queue[0] > 1:
            self.rate_limit_queue.popleft()
        
        if len(self.rate_limit_queue) >= 2:
            sleep_time = 1 - (now - self.rate_limit_queue[0])
            if sleep_time > 0:
                time.sleep(sleep_time)
        
        self.rate_limit_queue.append(time.time())
    
    def authenticate(self):
        """Authenticate with the 42 API using client credentials"""
        try:
            response = requests.post(
                f"{self.base_url}/oauth/token",
                data={
                    "grant_type": "client_credentials",
                    "client_id": self.client_id,
                    "client_secret": self.client_secret,
                },
                timeout=30
            )
            response.raise_for_status()
            self.access_token = response.json()["access_token"]
            print("‚úÖ Successfully authenticated with 42 API")
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Authentication failed: {e}")
            if hasattr(e, 'response') and e.response:
                print(f"Response status: {e.response.status_code}")
                print(f"Response text: {e.response.text}")
            raise
    
    def _save_api_response(self, endpoint: str, data: Union[Dict, List], params: Dict = None):
        """Save API response to a JSON file"""
        if not self.save_responses:
            return
        
        try:
            # Create a safe filename from the endpoint
            safe_endpoint = endpoint.replace('/', '_').replace('?', '_').strip('_')
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Add params to filename if they exist
            if params:
                param_str = '_'.join(f"{k}={v}" for k, v in params.items() if k not in ['page', 'per_page'])
                if param_str:
                    safe_endpoint += f"_{param_str}"
            
            filename = f"{self.api_responses_dir}/{safe_endpoint}_{timestamp}.json"
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump({
                    'endpoint': endpoint,
                    'params': params,
                    'timestamp': timestamp,
                    'data': data
                }, f, indent=2, ensure_ascii=False)
            
            print(f"üíæ Saved API response to: {filename}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to save API response: {e}")
    
    def make_api_request(self, endpoint: str, params: Dict = None) -> Dict:
        """Make authenticated API request to 42 Intra with rate limiting"""
        self.rate_limit_delay()
        
        headers = {"Authorization": f"Bearer {self.access_token}"}
        url = f"{self.base_url}{endpoint}"
        
        try:
            response = requests.get(url, headers=headers, params=params, timeout=30)
            
            if response.status_code == 429:
                print("‚ö†Ô∏è Rate limit hit, waiting 5 seconds...")
                time.sleep(5)
                return self.make_api_request(endpoint, params)
            
            response.raise_for_status()
            data = response.json()
            
            # Save the response to a file
            self._save_api_response(endpoint, data, params)
            
            return data
            
        except requests.exceptions.RequestException as e:
            print(f"‚ùå API request failed for {endpoint}: {e}")
            if hasattr(e, 'response') and e.response:
                print(f"Response status: {e.response.status_code}")
            return {}
    
    def get_all_paginated_data(self, endpoint: str, params: Dict = None) -> List[Dict]:
        """Get all data from paginated endpoints"""
        all_data = []
        page = 1
        page_size = 100
        
        while True:
            if params is None:
                params = {}
            
            params['page'] = page
            params['per_page'] = page_size
            
            print(f"üìÑ Fetching page {page} for {endpoint}...")
            
            data = self.make_api_request(endpoint, params)
            
            if not data or not isinstance(data, list):
                break
                
            if not data:
                break
                
            all_data.extend(data)
            
            if len(data) < page_size:
                break
                
            page += 1
            
            if page > 10:  # Reduced safety limit
                print("‚ö†Ô∏è Safety limit reached, stopping pagination")
                break
        
        print(f"‚úÖ Retrieved {len(all_data)} items from {endpoint}")
        
        # Save the combined paginated data
        if self.save_responses and all_data:
            self._save_api_response(f"{endpoint}_ALL_PAGES", all_data, params)
        
        return all_data
    
    def get_user_info(self, login: str) -> Dict:
        """Get basic user information"""
        return self.make_api_request(f"/v2/users/{login}")
    
    def get_user_cursus_users(self, user_id: int) -> List[Dict]:
        """Get user's cursus information including black hole date"""
        return self.get_all_paginated_data(f"/v2/users/{user_id}/cursus_users")
    
    def get_cursus_projects(self, cursus_id: int) -> List[Dict]:
        """Get all projects for a specific cursus"""
        return self.get_all_paginated_data(f"/v2/cursus/{cursus_id}/projects")
    
    def get_user_projects(self, user_id: int) -> List[Dict]:
        """Get all projects completed by user"""
        params = {'filter[user_id]': user_id}
        return self.get_all_paginated_data("/v2/projects_users", params)
    
    def get_user_locations(self, user_id: int) -> List[Dict]:
        """Get user's campus locations and check-in history"""
        return self.get_all_paginated_data(f"/v2/users/{user_id}/locations")
    
    def get_user_scale_teams(self, user_id: int) -> List[Dict]:
        """Get user's scale teams (evaluations) to detect activity gaps"""
        params = {'user_id': user_id}
        return self.get_all_paginated_data("/v2/scale_teams", params)
    
    def get_user_achievements(self, user_id: int) -> List[Dict]:
        """Get user achievements to detect system type"""
        return self.get_all_paginated_data(f"/v2/users/{user_id}/achievements")
    
    def get_42_circle_structure(self) -> Dict:
        """
        Define 42 circle structure with required projects for each circle
        Now includes optional projects (either/or choices)
        """
        return {
            1: {
                "name": "Circle 1 - Fundamentals",
                "required_projects": ["libft"],
                "description": "Master C programming basics",
                "min_projects": 1
            },
            2: {
                "name": "Circle 2 - Core Systems",
                "required_projects": [
                    "get_next_line", 
                    "ft_printf", 
                    "born2beroot"
                ],
                "description": "File I/O, formatted output, and system administration",
                "min_projects": 2  # Need 2 out of 3 to progress
            },
            3: {
                "name": "Circle 3 - Algorithms & Graphics",
                "required_projects": [
                    ["pipex", "minitalk"],  # Either pipex OR minitalk
                    "push_swap",
                    ["fdf", "so_long", "fract-ol"]  # Either fdf OR so_long OR fract-ol
                ],
                "description": "Processes, signals, sorting algorithms, and 2D graphics",
                "min_projects": 3  # Need 3 projects total (counting either/or as 1 each)
            },
            4: {
                "name": "Circle 4 - Advanced Systems",
                "required_projects": [
                    ["minishell", "Philosophers"]  # Either minishell OR Philosophers
                ],
                "description": "Shell implementation and concurrent programming",
                "min_projects": 1  # Need 1 out of 2 to progress
            },
            5: {
                "name": "Circle 5 - C++ & 3D",
                "required_projects": [
                    "cpp-module-00", 
                    "cpp-module-01", 
                    "cpp-module-02", 
                    "cpp-module-03", 
                    "cpp-module-04",
                    ["cub3d", "minirt"],  # Either cub3d OR minirt
                    "netpractice"
                ],
                "description": "C++ programming and 3D graphics",
                "min_projects": 6  # Need 6 out of 7 (counting either/or as 1)
            },
            6: {
                "name": "Circle 6 - Web & Networks",
                "required_projects": [
                    ["ft_irc", "webserv"],  # Either ft_irc OR webserv
                    "inception",
                    "cpp-module-05", 
                    "cpp-module-06", 
                    "cpp-module-07", 
                    "cpp-module-08", 
                    "cpp-module-09"
                ],
                "description": "Network programming and web services",
                "min_projects": 6  # Need 6 out of 8 (counting either/or as 1)
            },
            7: {
                "name": "Circle 7 - Specialization",
                "required_projects": ["ft_transcendence"],
                "description": "Full-stack web application",
                "min_projects": 1
            }
        }
    
    def get_project_time_estimates(self) -> Dict:
        """
        Get realistic time estimates for 42 projects based on actual curriculum
        and student feedback
        """
        return {
            # Circle 1
            "libft": {"weeks": 2, "difficulty": "medium", "hours": 40, "type": "foundation"},
            
            # Circle 2
            "get_next_line": {"weeks": 1, "difficulty": "medium", "hours": 25, "type": "file_io"},
            "ft_printf": {"weeks": 2, "difficulty": "hard", "hours": 50, "type": "formatting"},
            "born2beroot": {"weeks": 1, "difficulty": "easy", "hours": 20, "type": "sysadmin"},
            
            # Circle 3
            "pipex": {"weeks": 2, "difficulty": "hard", "hours": 45, "type": "processes"},
            "minitalk": {"weeks": 1, "difficulty": "medium", "hours": 30, "type": "signals"},
            "push_swap": {"weeks": 3, "difficulty": "very_hard", "hours": 80, "type": "algorithms"},
            "fdf": {"weeks": 2, "difficulty": "medium", "hours": 40, "type": "graphics"},
            "fract-ol": {"weeks": 2, "difficulty": "medium", "hours": 35, "type": "graphics"},
            "so_long": {"weeks": 2, "difficulty": "medium", "hours": 40, "type": "game"},
            
            # Circle 4
            "minishell": {"weeks": 4, "difficulty": "very_hard", "hours": 120, "type": "systems"},
            "Philosophers": {"weeks": 3, "difficulty": "very_hard", "hours": 90, "type": "concurrency"},
            
            # Circle 5
            "cpp-module-00": {"weeks": 1, "difficulty": "easy", "hours": 15, "type": "cpp"},
            "cpp-module-01": {"weeks": 1, "difficulty": "easy", "hours": 20, "type": "cpp"},
            "cpp-module-02": {"weeks": 1, "difficulty": "medium", "hours": 25, "type": "cpp"},
            "cpp-module-03": {"weeks": 2, "difficulty": "medium", "hours": 35, "type": "cpp"},
            "cpp-module-04": {"weeks": 2, "difficulty": "hard", "hours": 45, "type": "cpp"},
            "cub3d": {"weeks": 3, "difficulty": "very_hard", "hours": 100, "type": "3d_graphics"},
            "netpractice": {"weeks": 1, "difficulty": "easy", "hours": 15, "type": "networking"},
            "minirt": {"weeks": 4, "difficulty": "very_hard", "hours": 120, "type": "ray_tracing"},
            
            # Circle 6
            "ft_irc": {"weeks": 4, "difficulty": "very_hard", "hours": 110, "type": "networking"},
            "webserv": {"weeks": 4, "difficulty": "very_hard", "hours": 130, "type": "web"},
            "inception": {"weeks": 2, "difficulty": "medium", "hours": 40, "type": "devops"},
            "cpp-module-05": {"weeks": 2, "difficulty": "hard", "hours": 50, "type": "cpp"},
            "cpp-module-06": {"weeks": 2, "difficulty": "hard", "hours": 55, "type": "cpp"},
            "cpp-module-07": {"weeks": 2, "difficulty": "hard", "hours": 60, "type": "cpp"},
            "cpp-module-08": {"weeks": 2, "difficulty": "very_hard", "hours": 70, "type": "cpp"},
            "cpp-module-09": {"weeks": 2, "difficulty": "very_hard", "hours": 75, "type": "cpp"},
            
            # Circle 7
            "ft_transcendence": {"weeks": 6, "difficulty": "very_hard", "hours": 200, "type": "fullstack"}
        }

    def _detect_system_type(self, user_id: int, cursus_users: List[Dict]) -> str:
        """
        Detect whether user is under old black hole system or new pace system
        """
        try:
            # Check achievements for pace system indicators
            achievements = self.get_user_achievements(user_id)
            
            # Look for pace-related achievements
            pace_indicators = ["pace", "velocity", "sprint", "iteration"]
            for achievement in achievements:
                name = achievement.get('name', '').lower()
                description = achievement.get('description', '').lower()
                if any(indicator in name or indicator in description for indicator in pace_indicators):
                    return "pace"
            
            # Check cursus information
            for cursus in cursus_users:
                cursus_name = cursus.get('cursus', {}).get('name', '').lower()
                if 'pace' in cursus_name or 'velocity' in cursus_name:
                    return "pace"
                
                # Check if blackholed_at exists and has reasonable value
                blackholed_at = cursus.get('blackholed_at')
                if blackholed_at:
                    try:
                        bh_date = datetime.fromisoformat(blackholed_at.replace('Z', '+00:00'))
                        # If black hole date is more than 2 years from start, likely pace system
                        begin_at = cursus.get('begin_at')
                        if begin_at:
                            start_date = datetime.fromisoformat(begin_at.replace('Z', '+00:00'))
                            days_diff = (bh_date - start_date).days
                            if days_diff > 730:  # More than 2 years
                                return "pace"
                    except:
                        pass
            
            # Default to old system for older students
            return "old_blackhole"
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error detecting system type: {e}")
            return "old_blackhole"

    def _detect_freeze_periods(self, user_id: int, begin_at: str, current_date: datetime) -> List[Dict]:
        """
        Detect freeze periods by analyzing gaps in activity
        """
        freeze_periods = []
        
        try:
            # Get user locations to detect campus activity
            locations = self.get_user_locations(user_id)
            # Get scale teams to detect evaluation activity
            scale_teams = self.get_user_scale_teams(user_id)
            
            # Collect all activity dates
            activity_dates = []
            
            # Add location dates
            for location in locations:
                if location.get('end_at'):
                    try:
                        end_date = datetime.fromisoformat(location['end_at'].replace('Z', '+00:00'))
                        activity_dates.append(end_date.date())
                    except:
                        pass
            
            # Add scale team dates
            for scale_team in scale_teams:
                if scale_team.get('filled_at'):
                    try:
                        filled_date = datetime.fromisoformat(scale_team['filled_at'].replace('Z', '+00:00'))
                        activity_dates.append(filled_date.date())
                    except:
                        pass
            
            # Remove duplicates and sort
            activity_dates = sorted(list(set(activity_dates)))
            
            if not activity_dates:
                return freeze_periods
            
            # Convert start date
            start_date = datetime.fromisoformat(begin_at.replace('Z', '+00:00')).date()
            
            # Find gaps in activity (potential freeze periods)
            current_date_date = current_date.date()
            previous_date = start_date
            
            for activity_date in activity_dates:
                # Check if gap is significant (more than 30 days)
                gap_days = (activity_date - previous_date).days
                if gap_days > 30:
                    freeze_periods.append({
                        'start': previous_date,
                        'end': activity_date,
                        'days': gap_days,
                        'type': 'detected_gap'
                    })
                previous_date = activity_date
            
            # Check for gap from last activity to current date
            last_activity = max(activity_dates)
            gap_days = (current_date_date - last_activity).days
            if gap_days > 30:
                freeze_periods.append({
                    'start': last_activity,
                    'end': current_date_date,
                    'days': gap_days,
                    'type': 'current_gap'
                })
            
            print(f"‚ùÑÔ∏è  Detected {len(freeze_periods)} potential freeze periods")
            for i, freeze in enumerate(freeze_periods, 1):
                print(f"   Period {i}: {freeze['start']} to {freeze['end']} ({freeze['days']} days)")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error detecting freeze periods: {e}")
        
        return freeze_periods

    def _calculate_old_blackhole_date(self, user_id: int, begin_at: str, current_date: datetime, freeze_periods: List[Dict]) -> Tuple[Optional[datetime], Optional[int], bool]:
        """
        Calculate black hole date for OLD system (455 days + freezes)
        """
        try:
            start_date = datetime.fromisoformat(begin_at.replace('Z', '+00:00'))
            
            # OLD SYSTEM: Base 455 days (65 weeks)
            base_blackhole_days = 455
            base_blackhole_date = start_date + timedelta(days=base_blackhole_days)
            
            # Calculate total freeze days
            total_freeze_days = sum(freeze['days'] for freeze in freeze_periods)
            
            # Apply freeze extensions
            final_blackhole_date = base_blackhole_date + timedelta(days=total_freeze_days)
            
            days_until = (final_blackhole_date - current_date).days
            is_blackholed = days_until <= 0
            
            print(f"üìÖ OLD SYSTEM Calculation:")
            print(f"   Base Period: {base_blackhole_days} days")
            print(f"   Freeze Extensions: +{total_freeze_days} days")
            print(f"   Final Date: {final_blackhole_date.date()}")
            
            return final_blackhole_date, days_until, is_blackholed
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error in old system calculation: {e}")
            return None, None, False

    def _calculate_pace_system_date(self, user_id: int, begin_at: str, current_date: datetime, freeze_periods: List[Dict], level: float) -> Tuple[Optional[datetime], Optional[int], bool]:
        """
        Calculate black hole date for NEW PACE system
        """
        try:
            start_date = datetime.fromisoformat(begin_at.replace('Z', '+00:00'))
            
            # NEW PACE SYSTEM: Much longer periods based on level progression
            # Base period increases with level
            base_days_per_level = 120  # ~4 months per level in pace system
            current_level = level if level else 0
            
            # Minimum base period for pace system (even at level 0)
            base_blackhole_days = max(365, int(current_level * base_days_per_level) + 180)
            
            base_blackhole_date = start_date + timedelta(days=base_blackhole_days)
            
            # Calculate total freeze days
            total_freeze_days = sum(freeze['days'] for freeze in freeze_periods)
            
            # Apply freeze extensions
            final_blackhole_date = base_blackhole_date + timedelta(days=total_freeze_days)
            
            days_until = (final_blackhole_date - current_date).days
            is_blackholed = days_until <= 0
            
            print(f"üìÖ PACE SYSTEM Calculation:")
            print(f"   Current Level: {current_level}")
            print(f"   Base Period: {base_blackhole_days} days (based on level)")
            print(f"   Freeze Extensions: +{total_freeze_days} days")
            print(f"   Final Date: {final_blackhole_date.date()}")
            
            return final_blackhole_date, days_until, is_blackholed
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error in pace system calculation: {e}")
            return None, None, False

    def _calculate_accurate_blackhole_date(self, user_id: int, begin_at: str, current_date: datetime, blackholed_at: str = None, cursus_users: List[Dict] = None, level: float = 0) -> Tuple[Optional[datetime], Optional[int], bool, List[Dict], str]:
        """
        Calculate accurate black hole date based on detected system type
        """
        freeze_periods = []
        system_type = "old_blackhole"
        
        try:
            # If API provides blackholed_at, use it as it should already account for system type and freezes
            if blackholed_at:
                try:
                    api_blackhole_date = datetime.fromisoformat(blackholed_at.replace('Z', '+00:00'))
                    days_until = (api_blackhole_date - current_date).days
                    is_blackholed = days_until <= 0
                    
                    # Detect system type based on the API date
                    if begin_at:
                        start_date = datetime.fromisoformat(begin_at.replace('Z', '+00:00'))
                        total_days = (api_blackhole_date - start_date).days
                        if total_days > 600:  # More than ~20 months
                            system_type = "pace"
                        else:
                            system_type = "old_blackhole"
                    
                    print(f"üìÖ Using API blackhole date ({system_type}): {api_blackhole_date.date()}")
                    return api_blackhole_date, days_until, is_blackholed, freeze_periods, system_type
                except (ValueError, TypeError) as e:
                    print(f"‚ö†Ô∏è Error parsing API blackhole date, calculating manually: {e}")
            
            # Detect system type
            if cursus_users:
                system_type = self._detect_system_type(user_id, cursus_users)
            
            # Detect freeze periods
            freeze_periods = self._detect_freeze_periods(user_id, begin_at, current_date)
            
            # Calculate based on system type
            if system_type == "pace":
                blackhole_date, days_until, is_blackholed = self._calculate_pace_system_date(
                    user_id, begin_at, current_date, freeze_periods, level
                )
            else:
                blackhole_date, days_until, is_blackholed = self._calculate_old_blackhole_date(
                    user_id, begin_at, current_date, freeze_periods
                )
            
            return blackhole_date, days_until, is_blackholed, freeze_periods, system_type
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error in accurate black hole calculation: {e}")
            return None, None, False, freeze_periods, system_type

    def _is_project_completed(self, project_name: str, completed_projects: set) -> bool:
        """Check if a project (or any of its alternatives) is completed"""
        normalized_name = self._normalize_name(project_name)
        
        # Check if this exact project is completed
        for completed in completed_projects:
            if normalized_name in completed or completed in normalized_name:
                return True
        return False
    
    def _normalize_name(self, name: str) -> str:
        """Normalize project name for comparison"""
        if not name:
            return ""
        name = name.lower().strip()
        # Remove common variations
        name = name.replace('_', ' ').replace('-', ' ')
        # Remove extra spaces
        name = ' '.join(name.split())
        return name

    def calculate_blackhole_status(self, login: str) -> Dict:
        """
        Calculate accurate black hole status using proper API endpoints
        """
        print(f"üîç Analyzing black hole status for {login}...")
        
        user_info = self.get_user_info(login)
        if not user_info:
            return {"error": "User not found"}
        
        print(f"‚úÖ Found user: {user_info.get('displayname', login)}")
        
        user_id = user_info.get("id")
        if not user_id:
            return {"error": "Could not get user ID"}
        
        # Get user's cursus information (contains black hole date!)
        cursus_users = self.get_user_cursus_users(user_id)
        if not cursus_users:
            return {"error": "No cursus information found"}
        
        # Find the main 42 cursus (usually the first one)
        main_cursus = None
        for cursus in cursus_users:
            cursus_name = cursus.get('cursus', {}).get('name', '').lower()
            if '42' in cursus_name or cursus.get('cursus_id') == 1:
                main_cursus = cursus
                break
        
        if not main_cursus:
            main_cursus = cursus_users[0]  # Fallback to first cursus
        
        # Extract key information
        blackholed_at = main_cursus.get('blackholed_at')
        begin_at = main_cursus.get('begin_at')  # This is the start date
        level = main_cursus.get('level', 0)
        cursus_id = main_cursus.get('cursus_id')
        cursus_name = main_cursus.get('cursus', {}).get('name', 'Unknown Cursus')
        
        # Get user's projects
        user_projects = self.get_user_projects(user_id)
        
        # Calculate current status with safe date handling
        current_date = datetime.now().astimezone()
        
        # FIXED: Use accurate black hole calculation with system detection
        blackhole_date, days_until_blackhole, is_blackholed, freeze_periods, system_type = self._calculate_accurate_blackhole_date(
            user_id, begin_at, current_date, blackholed_at, cursus_users, level
        )
        
        # Calculate projects information
        completed_projects = self._get_completed_projects(user_projects)
        
        # Calculate circle progress using the new accurate method
        circle_info = self._calculate_circle_progress(completed_projects)
        
        # Get the actual remaining projects for the CURRENT circle
        current_circle_projects = self._get_remaining_projects_for_current_circle(
            completed_projects, 
            circle_info.get('current_circle', 0)
        )
        
        # Calculate risk level safely (different thresholds for different systems)
        risk_level = self._calculate_risk_level(days_until_blackhole, level, circle_info, system_type)
        
        return {
            "user_login": user_info.get("login"),
            "user_name": user_info.get("displayname"),
            "cursus": cursus_name,
            "level": level,
            "begin_at": begin_at,
            "blackholed_at": blackholed_at,
            "blackhole_date": blackhole_date.isoformat() if blackhole_date else None,
            "days_until_blackhole": days_until_blackhole,
            "is_blackholed": is_blackholed,
            "total_completed": len(completed_projects),
            "circle_info": circle_info,
            "remaining_projects": current_circle_projects,
            "risk_level": risk_level,
            "freeze_periods": freeze_periods,
            "total_freeze_days": sum(freeze['days'] for freeze in freeze_periods),
            "system_type": system_type
        }
    
    def _get_completed_projects(self, projects_users: List[Dict]) -> List[Dict]:
        """Get completed and validated projects"""
        completed = []
        for project_user in projects_users:
            if not isinstance(project_user, dict):
                continue
            
            status = project_user.get("status", "")
            final_mark = project_user.get("final_mark", 0)
            
            # Safely check if project is completed
            if status in ["finished", "success"] and final_mark is not None and final_mark >= 50:
                project_data = project_user.get("project", {})
                if project_data:
                    completed.append({
                        "id": project_data.get("id"),
                        "name": project_data.get("name"),
                        "slug": project_data.get("slug"),
                        "final_mark": final_mark,
                    })
        return completed
    
    def _calculate_circle_progress(self, completed_projects: List[Dict]) -> Dict:
        """
        Calculate current circle based on milestone projects with optional projects
        """
        # Build set of completed project names (normalized)
        completed_names = {self._normalize_name(p.get("name", "")) for p in completed_projects}
        completed_slugs = {self._normalize_name(p.get("slug", "")) for p in completed_projects}
        all_completed = completed_names.union(completed_slugs)
        
        circle_structure = self.get_42_circle_structure()
        
        current_circle = 1  # Start at circle 1 (everyone is at least in circle 1 after piscine)
        highest_circle_with_progress = 1
        
        # Find the highest circle where the user has made progress
        for circle_num in sorted(circle_structure.keys()):
            circle_data = circle_structure[circle_num]
            required_projects = circle_data["required_projects"]
            min_projects = circle_data.get("min_projects", 1)
            
            # Count how many required project GROUPS are completed
            completed_groups = 0
            
            for project_group in required_projects:
                if isinstance(project_group, list):
                    # This is an "either/or" group - check if any project in the group is completed
                    group_completed = False
                    for project in project_group:
                        if self._is_project_completed(project, all_completed):
                            group_completed = True
                            break
                    if group_completed:
                        completed_groups += 1
                else:
                    # This is a single required project
                    if self._is_project_completed(project_group, all_completed):
                        completed_groups += 1
            
            # If user has completed at least 1 project group in this circle, they've reached it
            if completed_groups > 0:
                highest_circle_with_progress = circle_num
                
            # If user has completed minimum required project groups, they can progress
            if completed_groups >= min_projects:
                current_circle = circle_num + 1  # They can move to next circle
            else:
                # Stop at the first circle where they haven't met requirements
                break
        
        # Ensure current circle doesn't exceed the highest circle with progress
        current_circle = min(current_circle, highest_circle_with_progress + 1)
        current_circle = min(current_circle, max(circle_structure.keys()))
        
        # Calculate progress for current circle
        current_circle_data = circle_structure.get(current_circle, {})
        current_required = current_circle_data.get("required_projects", [])
        current_min = current_circle_data.get("min_projects", 1)
        
        completed_in_current = 0
        missing_in_current = []
        
        for project_group in current_required:
            if isinstance(project_group, list):
                # Check if any project in this either/or group is completed
                group_completed = False
                for project in project_group:
                    if self._is_project_completed(project, all_completed):
                        group_completed = True
                        break
                
                if group_completed:
                    completed_in_current += 1
                else:
                    # Add the first project from the group as missing (user can choose any)
                    missing_in_current.append(f"Either: {', '.join(project_group)}")
            else:
                # Single required project
                if self._is_project_completed(project_group, all_completed):
                    completed_in_current += 1
                else:
                    missing_in_current.append(project_group)
        
        remaining_in_current = max(0, current_min - completed_in_current)
        is_on_track = completed_in_current >= current_min
        
        next_circle = current_circle + 1 if current_circle < max(circle_structure.keys()) else None
        
        return {
            "current_circle": current_circle,
            "next_circle": next_circle,
            "completed_in_current": completed_in_current,
            "required_in_current": current_min,
            "remaining_in_current": remaining_in_current,
            "missing_projects": missing_in_current,
            "is_on_track": is_on_track,
            "current_circle_name": circle_structure.get(current_circle, {}).get("name", f"Circle {current_circle}"),
            "next_circle_name": circle_structure.get(next_circle, {}).get("name", f"Circle {next_circle}") if next_circle else None,
            "highest_circle_reached": highest_circle_with_progress
        }
    
    def _get_remaining_projects_for_current_circle(self, completed_projects: List[Dict], current_circle: int) -> List[Dict]:
        """Get only the projects needed for the CURRENT circle progression"""
        if not current_circle:
            return []
        
        circle_structure = self.get_42_circle_structure()
        current_circle_data = circle_structure.get(current_circle, {})
        required_projects = current_circle_data.get("required_projects", [])
        project_time_estimates = self.get_project_time_estimates()
        
        # Get completed project names
        completed_names = {self._normalize_name(p.get("name", "")) for p in completed_projects}
        completed_slugs = {self._normalize_name(p.get("slug", "")) for p in completed_projects}
        all_completed = completed_names.union(completed_slugs)
        
        # Find which required project groups are NOT completed
        remaining = []
        
        for project_group in required_projects:
            if isinstance(project_group, list):
                # Check if any project in this either/or group is completed
                group_completed = False
                for project in project_group:
                    if self._is_project_completed(project, all_completed):
                        group_completed = True
                        break
                
                if not group_completed:
                    # Add all options from this group as remaining (user can choose any)
                    for project in project_group:
                        time_estimate = project_time_estimates.get(project, {"weeks": 2, "difficulty": "medium", "hours": 40})
                        remaining.append({
                            "name": project,
                            "slug": project.lower().replace(' ', '-'),
                            "description": f"Optional: Choose one from {', '.join(project_group)}",
                            "circle": current_circle,
                            "estimated_weeks": time_estimate["weeks"],
                            "estimated_hours": time_estimate["hours"],
                            "difficulty": time_estimate["difficulty"],
                            "type": time_estimate.get("type", "general"),
                            "is_optional": True,
                            "alternatives": [p for p in project_group if p != project]
                        })
            else:
                # Single required project
                if not self._is_project_completed(project_group, all_completed):
                    time_estimate = project_time_estimates.get(project_group, {"weeks": 2, "difficulty": "medium", "hours": 40})
                    remaining.append({
                        "name": project_group,
                        "slug": project_group.lower().replace(' ', '-'),
                        "description": f"Required for {current_circle_data.get('name', f'Circle {current_circle}')}",
                        "circle": current_circle,
                        "estimated_weeks": time_estimate["weeks"],
                        "estimated_hours": time_estimate["hours"],
                        "difficulty": time_estimate["difficulty"],
                        "type": time_estimate.get("type", "general"),
                        "is_optional": False,
                        "alternatives": []
                    })
        
        return remaining
    
    def _calculate_risk_level(self, days_until_blackhole: Optional[int], current_level: float, circle_info: Dict, system_type: str) -> str:
        """Calculate risk level based on black hole date and progress"""
        if days_until_blackhole is None:
            return "UNKNOWN"
        
        safe_days = days_until_blackhole
        safe_level = current_level if current_level is not None else 0
        current_circle = circle_info.get("current_circle", 0)
        is_on_track = circle_info.get("is_on_track", False)
        
        # Different risk thresholds for different systems
        if system_type == "pace":
            # Pace system has much longer timelines
            if safe_days <= 0:
                return "BLACK_HOLED"
            elif safe_days <= 90:  # 3 months in pace system is critical
                return "CRITICAL"
            elif safe_days <= 180:  # 6 months in pace system is high
                return "HIGH"
            elif safe_days <= 270:  # 9 months in pace system is medium
                return "MEDIUM"
            elif safe_days <= 365 and not is_on_track:  # 1 year in pace system
                return "LOW"
            else:
                return "SAFE"
        else:
            # Old black hole system (shorter timelines)
            if safe_days <= 0:
                return "BLACK_HOLED"
            elif safe_days <= 30:
                return "CRITICAL"
            elif safe_days <= 60:
                return "HIGH"
            elif safe_days <= 90:
                return "MEDIUM"
            elif safe_days <= 180 and not is_on_track:
                return "LOW"
            elif safe_level < 3.0 and current_circle <= 2 and safe_days <= 270:
                return "LOW"
            else:
                return "SAFE"
    
    def generate_escape_plan(self, login: str) -> Dict:
        """
        Generate a customized escape plan based on accurate black hole information
        """
        status = self.calculate_blackhole_status(login)
        
        if "error" in status:
            return status
        
        if status.get("is_blackholed"):
            return {
                "status": status,
                "escape_plan": {
                    "message": "üö® EMERGENCY: You have been black holed!",
                    "recommendations": [
                        "üö® Immediately contact your campus staff",
                        "üìû Speak with your assigned tutor or referent",
                        "üí° Discuss options for appeal or re-entry",
                        "üìù Prepare a detailed progress report",
                        "üéØ Create a recovery plan with staff guidance"
                    ]
                }
            }
        
        # Generate proactive escape plan
        days_remaining = status.get("days_until_blackhole")
        circle_info = status.get("circle_info", {})
        remaining_projects = status.get("remaining_projects", [])
        begin_at = status.get("begin_at")
        freeze_periods = status.get("freeze_periods", [])
        total_freeze_days = status.get("total_freeze_days", 0)
        system_type = status.get("system_type", "old_blackhole")
        
        if days_remaining is None or days_remaining > 1000:
            return {
                "status": status,
                "escape_plan": {
                    "message": "‚úÖ No black hole date set - you're safe for now!",
                    "recommendations": [
                        "üéØ Focus on consistent project completion",
                        "üìà Aim for at least 1 project per week",
                        "üë• Collaborate with peers on difficult projects",
                        "üìö Use available learning resources",
                        "‚è∞ Maintain steady progress to avoid future risks"
                    ]
                }
            }
        
        # Use the accurate projects needed for the CURRENT circle
        projects_needed = circle_info.get("remaining_in_current", 0)
        missing_projects = circle_info.get("missing_projects", [])
        
        # Calculate total time needed based on realistic project estimates
        # For optional projects, use the shortest estimated time
        total_weeks_needed = 0
        total_hours_needed = 0
        optional_groups_processed = set()
        
        for project in remaining_projects[:projects_needed]:
            if project.get("is_optional"):
                # For optional projects, only count each group once
                group_key = tuple(sorted(project.get("alternatives", []) + [project["name"]]))
                if group_key not in optional_groups_processed:
                    optional_groups_processed.add(group_key)
                    total_weeks_needed += project.get("estimated_weeks", 2)
                    total_hours_needed += project.get("estimated_hours", 40)
            else:
                total_weeks_needed += project.get("estimated_weeks", 2)
                total_hours_needed += project.get("estimated_hours", 40)
        
        # Ensure we have valid numbers for calculations
        safe_days_remaining = max(1, days_remaining) if days_remaining is not None else 30
        safe_projects_needed = max(1, projects_needed)
        
        # Create realistic weekly plan based on project time estimates
        weekly_plan = self._create_realistic_weekly_schedule(remaining_projects, safe_days_remaining, safe_projects_needed)
        
        # Calculate if the timeline is realistic
        weeks_available = math.ceil(safe_days_remaining / 7)
        timeline_feasible = total_weeks_needed <= weeks_available
        
        escape_plan = {
            "start_date": begin_at,
            "blackhole_date": status.get("blackhole_date"),
            "days_remaining": days_remaining,
            "weeks_available": weeks_available,
            "current_circle": circle_info.get("current_circle", 0),
            "current_circle_name": circle_info.get("current_circle_name", ""),
            "next_circle": circle_info.get("next_circle"),
            "next_circle_name": circle_info.get("next_circle_name", ""),
            "projects_completed_current": circle_info.get("completed_in_current", 0),
            "projects_required_current": circle_info.get("required_in_current", 0),
            "projects_remaining_current": projects_needed,
            "total_weeks_needed": total_weeks_needed,
            "total_hours_needed": total_hours_needed,
            "timeline_feasible": timeline_feasible,
            "required_projects": safe_projects_needed,
            "weekly_schedule": weekly_plan,
            "priority_projects": [p.get("name", "Unknown") for p in remaining_projects],
            "missing_projects": missing_projects,
            "freeze_periods": freeze_periods,
            "total_freeze_days": total_freeze_days,
            "system_type": system_type,
            "recommendations": self._generate_realistic_recommendations(
                status, days_remaining, total_weeks_needed, weeks_available, timeline_feasible
            )
        }
        
        return {
            "status": status,
            "escape_plan": escape_plan
        }
    
    def _create_realistic_weekly_schedule(self, projects: List[Dict], days_remaining: int, required_count: int) -> List[Dict]:
        """Create a realistic weekly schedule based on project time estimates"""
        if not projects:
            return []
            
        weeks_available = math.ceil(days_remaining / 7)
        projects_to_schedule = projects[:required_count]
        
        weekly_schedule = []
        current_week = 1
        scheduled_projects = []
        scheduled_optional_groups = set()
        
        # Sort projects by estimated weeks (longest first to schedule them early)
        # For optional projects, prefer the ones with shorter estimated times
        projects_to_schedule.sort(key=lambda x: (
            -x.get("estimated_weeks", 2),  # Longer projects first
            len(x.get("alternatives", []))  # Optional projects with more alternatives first
        ))
        
        for project in projects_to_schedule:
            # Skip if this is an optional project from a group we've already scheduled
            if project.get("is_optional"):
                group_key = tuple(sorted(project.get("alternatives", []) + [project["name"]]))
                if group_key in scheduled_optional_groups:
                    continue
            
            project_weeks = project.get("estimated_weeks", 2)
            project_name = project.get("name", "Unknown Project")
            project_hours = project.get("estimated_hours", 40)
            difficulty = project.get("difficulty", "medium")
            is_optional = project.get("is_optional", False)
            
            # Check if we can fit this project in the remaining weeks
            if current_week + project_weeks - 1 > weeks_available:
                # If not, skip this project (it won't fit in the timeline)
                continue
            
            # Schedule the project
            for week_offset in range(project_weeks):
                week_num = current_week + week_offset
                
                # Find or create the week entry
                week_entry = None
                for entry in weekly_schedule:
                    if entry["week"] == week_num:
                        week_entry = entry
                        break
                
                if not week_entry:
                    week_entry = {
                        "week": week_num,
                        "focus_projects": [],
                        "weekly_goals": [],
                        "total_hours": 0
                    }
                    weekly_schedule.append(week_entry)
                
                # Add project to this week (only once per project)
                if week_offset == 0:
                    project_info = {
                        "name": project_name,
                        "estimated_hours": project_hours,
                        "difficulty": difficulty,
                        "total_weeks": project_weeks,
                        "week_in_progress": 1,
                        "is_optional": is_optional
                    }
                    if is_optional:
                        project_info["alternatives"] = project.get("alternatives", [])
                    
                    week_entry["focus_projects"].append(project_info)
                    week_entry["total_hours"] += project_hours // project_weeks
                else:
                    # For subsequent weeks, just mark it as ongoing
                    for existing_project in week_entry["focus_projects"]:
                        if existing_project["name"] == project_name:
                            existing_project["week_in_progress"] = week_offset + 1
                            break
            
            current_week += project_weeks
            scheduled_projects.append(project)
            
            # Mark optional group as scheduled
            if project.get("is_optional"):
                group_key = tuple(sorted(project.get("alternatives", []) + [project["name"]]))
                scheduled_optional_groups.add(group_key)
            
            # Stop if we've scheduled all required projects or run out of weeks
            if len(scheduled_projects) >= required_count or current_week > weeks_available:
                break
        
        # Add weekly goals and format the schedule
        for week_entry in weekly_schedule:
            focus_projects = week_entry["focus_projects"]
            ongoing_projects = [p for p in focus_projects if p.get("week_in_progress", 1) > 1]
            new_projects = [p for p in focus_projects if p.get("week_in_progress", 1) == 1]
            
            goals = []
            if new_projects:
                new_projects_list = []
                for p in new_projects:
                    if p.get("is_optional"):
                        new_projects_list.append(f"{p['name']} (choose one from: {', '.join(p.get('alternatives', []))})")
                    else:
                        new_projects_list.append(p["name"])
                goals.append("Start: " + ", ".join(new_projects_list))
            
            if ongoing_projects:
                formatted = []
                for p in ongoing_projects:
                    status = f" (week {p.get('week_in_progress', 1)}/{p.get('total_weeks', 1)})"
                    formatted.append(f"{p['name']}{status}")
                goals.append("Continue: " + ", ".join(formatted))
            
            goals.extend([
                f"Target: {week_entry['total_hours']} hours of focused work",
                "Daily coding sessions: 4-6 hours",
                "Weekend: Intensive work and peer reviews"
            ])
            
            week_entry["weekly_goals"] = goals
        
        return weekly_schedule
    
    def _generate_realistic_recommendations(self, status: Dict, days_remaining: int, total_weeks_needed: int, 
                                         weeks_available: int, timeline_feasible: bool) -> List[str]:
        """Generate realistic recommendations based on project time estimates"""
        recommendations = []
        risk_level = status.get("risk_level", "UNKNOWN")
        current_level = status.get("level", 0)
        circle_info = status.get("circle_info", {})
        begin_at = status.get("begin_at")
        freeze_periods = status.get("freeze_periods", [])
        total_freeze_days = status.get("total_freeze_days", 0)
        system_type = status.get("system_type", "old_blackhole")
        
        # Removed: System type information display
        
        # Add freeze period information
        if freeze_periods:
            recommendations.append(f"‚ùÑÔ∏è  Freeze periods detected: {len(freeze_periods)} periods, {total_freeze_days} total days")
            recommendations.append("üìÖ Your black hole date has been extended due to freeze periods")
        
        # Timeline analysis
        if not timeline_feasible:
            recommendations.extend([
                "üö® TIMELINE CRITICAL: Your available time may not be sufficient",
                f"‚è∞ You need {total_weeks_needed} weeks but only have {weeks_available} weeks until black hole",
                "üí° Consider focusing on the most critical projects first",
                "üÜò Discuss timeline options with your campus staff"
            ])
        else:
            recommendations.append(f"‚úÖ Timeline looks feasible: {total_weeks_needed} weeks needed, {weeks_available} weeks available")
        
        # Removed: System-specific recommendations section
        # The rest of the recommendations remain the same but without system type mentions
        
        if risk_level == "CRITICAL":
            recommendations.extend([
                "üö® MAXIMUM EFFORT REQUIRED!",
                "‚è∞ Dedicate 6-8 hours daily to coding (40-50 hours/week)",
                "üéØ Focus on one project at a time to maximize efficiency",
                "üÜò Seek immediate help from staff and senior students",
                "üìû Daily check-ins with your tutor or referent"
            ])
        elif risk_level == "HIGH":
            recommendations.extend([
                "‚ö†Ô∏è HIGH INTENSITY NEEDED",
                "‚è∞ Dedicate 4-6 hours daily (30-40 hours/week)",
                "üë• Form dedicated study groups for each project",
                "üìä Track progress daily and adjust plan weekly",
                "üéØ Prioritize projects by circle progression impact"
            ])
        elif risk_level == "MEDIUM":
            recommendations.extend([
                "üî∂ CONSISTENT EFFORT REQUIRED",
                "‚è∞ Dedicate 3-4 hours daily (20-30 hours/week)",
                "üë• Regular peer programming sessions",
                "üìà Weekly progress reviews and plan adjustments",
                "üí° Balance project work with skill development"
            ])
        else:
            recommendations.extend([
                "‚úÖ STEADY PACE MAINTAINED",
                "‚è∞ 2-3 hours of focused coding daily (15-20 hours/week)",
                "üë• Help peers and reinforce learning through teaching",
                "üöÄ Challenge yourself with bonus objectives"
            ])
        
        # Add circle-specific advice
        current_circle = circle_info.get("current_circle", 0)
        completed_in_current = circle_info.get("completed_in_current", 0)
        required_in_current = circle_info.get("required_in_current", 0)
        
        recommendations.append(f"üéØ You are in Circle {current_circle}: {completed_in_current}/{required_in_current} project groups completed")
        
        # Add advice about optional projects
        if current_circle >= 3:  # Circles with optional projects start from circle 3
            recommendations.extend([
                "üîÑ REMEMBER: For optional projects, you only need to complete ONE from each group",
                "üí° Choose projects based on your interests and skills",
                "üìä Compare time estimates when selecting optional projects",
                "üë• Talk to peers who have completed different options"
            ])
        
        # Project-specific time management advice
        if current_circle >= 4:
            recommendations.extend([
                "‚è≥ Complex projects ahead: Plan for 3-4 week timelines",
                "üîß Break large projects into smaller milestones",
                "üìù Document your progress and challenges",
                "üîÑ Regular code reviews with peers"
            ])
        
        # Time management strategies
        recommendations.extend([
            "üìÖ Use time blocking: Dedicate specific hours each day to coding",
            "üéØ Set weekly milestones with clear deliverables",
            "üîÑ Review and adjust your plan every Sunday",
            "‚è∞ Track actual time spent vs estimated time"
        ])
        
        # Add black hole specific info
        if begin_at:
            try:
                start_date = datetime.fromisoformat(begin_at.replace('Z', '+00:00'))
                days_since_start = (datetime.now().astimezone() - start_date).days
                recommendations.append(f"üìÖ Started: {start_date.date()} ({days_since_start} days ago)")
            except:
                pass
        
        return recommendations

    def save_complete_user_data(self, login: str) -> str:
        """
        Fetch and save all available data for a user to JSON files.
        Responses from each API call are automatically saved by _save_api_response.
        This method also writes a SUMMARY.json file.
        """
        # Create user-specific directory and temporarily route all saves there
        base_dir = getattr(self, "api_responses_dir", "api_responses")
        user_dir = os.path.join(base_dir, login)
        os.makedirs(user_dir, exist_ok=True)

        original_dir = self.api_responses_dir
        self.api_responses_dir = user_dir
        try:
            print(f"üìä Fetching complete data for {login}...")

            # 1) User info
            user_info = self.get_user_info(login)
            if not user_info or 'id' not in user_info:
                print(f"‚ùå Could not find user {login}")
                return user_dir

            user_id = user_info['id']

            # 2) Cursus
            cursus_users = self.get_user_cursus_users(user_id)

            # 3) Projects
            user_projects = self.get_user_projects(user_id)

            # 4) Locations (check-ins)
            locations = self.get_user_locations(user_id)

            # 5) Scale teams (evaluations)
            scale_teams = self.get_user_scale_teams(user_id)

            # 6) Achievements
            achievements = self.get_user_achievements(user_id)

            # Write a compact summary file
            summary = {
                "fetched_at": datetime.now().isoformat(),
                "user_info": {
                    "id": user_info.get("id"),
                    "login": user_info.get("login"),
                    "displayname": user_info.get("displayname"),
                    "campus": [c.get("name") for c in (user_info.get("campus", []) or [])],
                },
                "counts": {
                    "cursus_users": len(cursus_users or []),
                    "projects_users": len(user_projects or []),
                    "locations": len(locations or []),
                    "scale_teams": len(scale_teams or []),
                    "achievements": len(achievements or []),
                }
            }
            with open(os.path.join(user_dir, "SUMMARY.json"), "w", encoding="utf-8") as f:
                json.dump(summary, f, indent=2, ensure_ascii=False)

            print(f"‚úÖ All data saved under: {user_dir}/")
            return user_dir
        finally:
            # Restore original save directory
            self.api_responses_dir = original_dir

def main():
    """
    Main function to demonstrate the accurate BlackHoleEscape system
    """
    CLIENT_ID = "u-s4t2ud-3f5a9f13d7684887260aa74bef6284a20f40ca1ebb45a79c84cca875bec5cb72"
    CLIENT_SECRET = "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"
    
    try:
        # Initialize with save_responses=True to save all API calls
        escape_system = BlackHoleEscape(CLIENT_ID, CLIENT_SECRET, save_responses=True)
        
        # Test with a real 42 login
        student_login = input("Enter 42 login: ").strip()
        if not student_login:
            student_login = "kskender"  # Fallback for testing
        
        # Ask if user wants to save complete data
        save_all = input("Do you want to save all API data to JSON files? (y/n): ").strip().lower()
        
        if save_all == 'y':
            print("\n" + "="*70)
            print("üì• SAVING ALL API DATA TO JSON FILES")
            print("="*70)
            user_dir = escape_system.save_complete_user_data(student_login)
            print(f"\n‚úÖ Complete API data saved to: {user_dir}/")
            print("\nYou can now examine the JSON files to see all available data from the API.")
            print("\n" + "="*70)
        
        print(f"\nüöÄ Starting Accurate Black Hole Escape Analysis for {student_login}...")
        print("=" * 70)
        
        result = escape_system.generate_escape_plan(student_login)
        
        # Save the final result
        if escape_system.save_responses:
            result_file = f"{escape_system.api_responses_dir}/{student_login}_escape_plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            with open(result_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False, default=str)
            print(f"\nüíæ Escape plan saved to: {result_file}")
        
        if "error" in result:
            print(f"‚ùå Error: {result['error']}")
            return
        
        status = result["status"]
        plan = result.get("escape_plan", {})
        
        print(f"\nüìä ACCURATE BLACK HOLE ANALYSIS")
        print(f"üë§ Student: {status.get('user_name', status.get('user_login'))}")
        print(f"üéì Cursus: {status.get('cursus', 'Unknown')}")
        print(f"üìà Level: {status.get('level', 'Unknown')}")
        print(f"üéØ Risk Level: {status.get('risk_level', 'UNKNOWN')}")
        
        blackhole_date = status.get('blackhole_date')
        begin_at = status.get('begin_at')
        freeze_periods = status.get('freeze_periods', [])
        total_freeze_days = status.get('total_freeze_days', 0)
        
        if begin_at:
            try:
                start_date = datetime.fromisoformat(begin_at.replace('Z', '+00:00'))
                days_since_start = (datetime.now().astimezone() - start_date).days
                print(f"üìÖ Start Date: {start_date.date()} ({days_since_start} days ago)")
            except:
                pass
        
        if blackhole_date:
            print(f"‚è∞ Black Hole Date: {blackhole_date}")
            print(f"üìÜ Days Remaining: {status.get('days_until_blackhole', 'Unknown')}")
        else:
            print(f"‚è∞ Black Hole Date: Not set (safe for now)")
        
        print(f"‚úÖ Projects Completed: {status.get('total_completed', 0)}")
        
        if freeze_periods:
            print(f"‚ùÑÔ∏è  Freeze Periods: {len(freeze_periods)} periods, {total_freeze_days} total days")
            for i, freeze in enumerate(freeze_periods, 1):
                print(f"   Period {i}: {freeze['start']} to {freeze['end']} ({freeze['days']} days)")
        
        circle_info = status.get('circle_info', {})
        current_circle = circle_info.get('current_circle', 0)
        print(f"üîÑ Current Circle: {current_circle} - {circle_info.get('current_circle_name', '')}")
        print(f"üìä Progress in Circle {current_circle}: {circle_info.get('completed_in_current', 0)}/{circle_info.get('required_in_current', 0)} project groups")
        
        next_circle = circle_info.get('next_circle')
        if next_circle is not None:
            print(f"üéØ Next Circle: {next_circle} - {circle_info.get('next_circle_name', '')}")
        
        if plan:
            print(f"\nüìù REALISTIC ESCAPE PLAN")
            if 'message' in plan:
                print(plan['message'])
            else:
                print(f"üéØ Required Project Groups for Circle {plan.get('current_circle')}: {plan.get('projects_remaining_current', 0)}")
                print(f"‚è∞ Total Time Needed: {plan.get('total_weeks_needed', 0)} weeks ({plan.get('total_hours_needed', 0)} hours)")
                print(f"üìÖ Weeks Available: {plan.get('weeks_available', 0)} weeks")
                print(f"üìà Timeline Feasible: {'‚úÖ YES' if plan.get('timeline_feasible') else '‚ùå NO'}")
                
                # Show freeze period information in escape plan
                if plan.get('freeze_periods'):
                    print(f"‚ùÑÔ∏è  Freeze periods accounted for: {plan.get('total_freeze_days', 0)} days")
                
                # Show exactly which projects are missing with time estimates
                missing_projects = plan.get('missing_projects', [])
                if missing_projects:
                    print(f"\nüéØ PROJECT GROUPS NEEDED FOR CIRCLE {plan.get('current_circle')}:")
                    for i, project in enumerate(missing_projects, 1):
                        if project.startswith("Either:"):
                            print(f"  {i}. {project}")
                        else:
                            time_est = escape_system.get_project_time_estimates().get(project, {"weeks": 2, "hours": 40})
                            print(f"  {i}. {project} - {time_est['weeks']} weeks, {time_est['hours']} hours ({time_est['difficulty']})")
                
                weekly_schedule = plan.get('weekly_schedule', [])
                if weekly_schedule:
                    print(f"\nüìÖ REALISTIC WEEKLY SCHEDULE:")
                    for week in weekly_schedule:
                        print(f"\nWeek {week.get('week', '?')}:")
                        for project in week.get('focus_projects', []):
                            status_str = f" (Week {project.get('week_in_progress', 1)}/{project.get('total_weeks', 2)})" if project.get('total_weeks', 2) > 1 else ""
                            optional_note = " [OPTIONAL - choose one]" if project.get('is_optional') else ""
                            print(f"   ‚Ä¢ {project.get('name', 'Unknown')}{status_str}{optional_note} - {project.get('estimated_hours', 0)} hours ({project.get('difficulty', 'medium')})")
                        for goal in week.get('weekly_goals', []):
                            print(f"   üéØ {goal}")
            
            recommendations = plan.get('recommendations', [])
            if recommendations:
                print(f"\nüí° REALISTIC RECOMMENDATIONS:")
                for rec in recommendations:
                    print(f"  ‚Ä¢ {rec}")
        
        print(f"\nüìÅ All API responses saved to: {escape_system.api_responses_dir}/")
            
    except Exception as e:
        print(f"‚ùå System error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()